---
title: "The cheby package (with applications in economics)"
author: "Philip Barrett"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{The cheby package (with applications in economics)}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Introduction

The `cheby` package provides easy-to-use Chebychev interpolation of an arbitrary R function.

Chebychev approximates an arbitrary function on a closed interval using an the Chebychev polynomials as a basis.  In general, polynomial approximation is helpful when a function $f:[a,b]\rightarrow \mathbb R$ is expensive to compute at all values in the domain.  So instead, one approximates $f(\cdot)$ is by $\hat f(\cdot)$, where:

  $$\hat f(x) = \sum_{i=1}^n a_i \phi_i(x) $$

Where $\psi_i(x)$ are polynomials.  In practice, this involves computing the function at a limited number of grid points, and then fitting a polynomial function through the function values at these points.  This fitting is typically done by linear regression of the points on the fitting polynomials.  This minimizes the square deviations at the grid points, but imposes no restrictions on the shape of the approximation.  If we want the resulting approximation to have particular properties (such as monotonicity or concavity), then we will need to use other methods.  This package provides functionality to fit one-dimensional functions both via convential Chebychev approximation, and by imposing constraints on the shape of the approximation.

The algorithms in this package draw heavily on Judd (1998).

# One-dimensional Chebychev approximation

## The Theory

Algorithm 6.2 of Judd (1998) outlines the steps required to produce the one dimensional Chebychev interpolation of order $n$ on $m$ nodes (with $n<m$) of the function $f:[a,b]\rightarrow \mathbb R$.

1. Compute the interpolaton nodes on $[-1,1]$ via:
    $$z_k = -\cos \left( \frac{2k-1}{2m}\pi \right)$$
1. Map the nodes to the interval $[a,b]$
    $$x_k = \left( \frac{b-a}{2} \right)(z_k+1) + a$$
1. Compute $f(\cdot)$ at the nodes
    $$y_k = f(x_k), \qquad k=1,\ldots,m$$
1. Regress the $y_k$ on the Chebychev polynomials $T_i(z)$ for $i=0,\ldots,n$
    $$a_i = \frac{\sum_{k=1}^m y_k T_i(z_k) }{\sum_{k=1}^m T_i(z_k)^2}$$
1. The Chebychev approximation is then given by:
    $$\hat f(x) = \sum_{i=1}^n a_i T_i\left(\frac{2(x-1)}{b-a}-1\right)$$

Theorem 6.7.3 of Judd (1998) shows that this approximation is pointwise-convergent for any $C^k$ function.

## Basic approximation

The basic command for Chebychev interpolation is `d1.poly`.  For example, to compute the approximation of the natural logarithm:

```{r}
suppressMessages(library(cheby))
base <- d1.poly( fn=log, range=c(.1,4), iOrder=6, iPts=10 )
```

This computes a 6th-order approximation to `log` on the interval $[0,4]$ (recall that `log` is not continuous at zero) using 10 grid points.   The output is a function that we can use straight away.  We can check the approximation at a few points:

```{r}
c( base(1), log(1) )
c( base(2), log(2) )
```

Better still, we can see the approximation visually:

```{r}
plot( log, xlim=c(.1, 4), type='l' ) 
plot( base, xlim=c(.1, 4), col='blue', add=TRUE )
```

So the approximation is very good.  And it is fast:

```{r}
library(microbenchmark)
microbenchmark(base <- d1.poly( fn=log, range=c(.1,4), iOrder=6, iPts=10 ))
```

However, the approximation is not concave - it oscilates slightly around the approximated function.  In some numerical calculations, preserving properties of the function can be important.  Later we will discuss how value function will often fail if the continuation value function is not concave, as then there is no unique local interior maximum.

## Extracting more information about the approximation



## Fixing the grid

## Other options

# One-dimensional shape-preserving Chebychev approximation


# An example with applications in economics


## The problem

## Value function iteration

## Solving the first-order conditions directly

# Two-dimensional approximation

# References
Judd (1998), Numerical Methods in Economics, MIT Press


<!--Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style

## Vignette Info

Note the various macros within the `vignette` setion of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872)) -->